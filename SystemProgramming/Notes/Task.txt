/* Многозадачность
Один из методов параллельного программирования с использованием специальных
объектов уровня языка программирования (ЯП) [ранее рассмотренные потоки - объекты ОС]
В разных ЯП они (задачи) имеют разные названия: Task, Promise, Future

Отличительные особенности задач:
- Метод задачи может принимать произвольное кол-во аргументов (метод потока - один)
- Метод задачи может возвращать значение (метод потока - нет)
- Задачи не всегда (не во всех ЯП) стартуют новые потоки. Если стартуют, то
   обычно в пуле потоков.

Появление объектов-задач привело к отделению алгоритмов работы с ними в 
особый контекст async.
Объявление асинхронного метода:
private async [void/Task/Task<Type>] MethodName(args) {
	await OtherMethod();  в асинхронном методе можно ожидать другие асинх методы
	                      БЕЗ БЛОКИРОВКИ СИНХРОННЫХ ПОТОКОВ
}
Асинхронный обработчик кнопки не будет блокировать интерфейс даже если внутри
него будет await
             async - await............ однако он не запрещает доступ к UI элементам
async click / - интерфейс свободен
        

await - не просто ожидание, а еще и извлечение результата, поэтому не применяется
к  async void  методам. Такие методы можно просто запустить, создав новую "нитку"
выполнения кода

Из синхронного контекста использовать await нельзя. Можно использовать конструкцию
Task.Run(PlusPercent).Wait(), но она заблокирует данный поток

           /-----------------------------\    задача в отдельном потоке, но вызывающий поток его ожидает
click - [Task.Run(...).Wait()] ...........    (интерфейс заблокирован)

           /----------------------- (из этой нитки нужен Dispatcher.Invoke)
click - Task.Run(...) - интерфейс свободен

Dispatcher.Invoke обращается к UI потоку и если он заблокирован, то также не может выполниться */
